-- join이란, 두개 이상의 테이블을 연결하여 데이터를 검색하는 방법
/*
<join의 종류>
cross join
inner join
outer join
self join
*/
-- 크로스 조인 : 한쪽 테이블의 각 행마다 다른 쪽 테이블의 모든 행이 한번씩
-- 매칭되는 조인을 의미
select 부서.부서번호,
	부서명,
	이름,
	사원.부서번호
from 부서
cross join 사원 -- join은 from 바로 다음에 쓰임, cross 조인은 잘 안쓰이고 사용할때면 주의해야됨
where 이름 = '배재용';

-- 내부조인(inner join) : 각 테이블에서 조인 조건에 일치하는 데이터만 조인
-- '이소미'사원의 사원번호, 직위, 부서번호, 부서명
-- ANSI SQL 조인
select 사원번호,
	직위,
	부서.부서번호,
	부서명
from 사원
inner join 부서
on 사원.부서번호 = 부서.부서번호
where 이름 = '이소미';

-- Non ANSI SQL 조인 (위 방법과 결과는 같으나 문법이 다름)
select 사원번호,
	직위,
	부서.부서번호,
	부서명
from 사원, 부서
where 사원.부서번호 = 부서.부서번호
and 이름 = '이소미';

-- 고객회사들이 주문한 주문건수를 많은 순서대로 보이시오
-- 컬럼은 고객번호, 담당자명, 고객회사명, 주문건수
select 고객.고객번호,
	담당자명,
	고객회사명,
	count(*) as 주문건수
from 고객
inner join 주문
on 고객.고객번호 = 주문.고객번호
group by 고객.고객번호, 담당자명, 고객회사명
order by count(*) desc;

-- 고객별로 주문금액 합을 보이되, 주문금액 합이 많은 순서대로
-- 컬럼은 고객번호, 담당자명, 고객회사명, 주문금액합
select 고객.고객번호,
	담당자명,
	고객회사명,
	sum(truncate((단가 * 주문수량 - (주문수량*단가*할인율)),1)) as 주문금액합 -- 유일한 값인 경우 굳이 어느테이블의 값인지 안적어도 됨
from 고객
inner join 주문
on 고객.고객번호 = 주문.고객번호
inner join 주문세부
on 주문.주문번호 = 주문세부.주문번호
-- 	from 고객, 주문, 주문세부 -- join의 형태가 정확이 인지되지 않아서 문제될 수 있음???
-- where 고객.고객번호 = 주문.고객번호 and 주문.주문번호 = 주문세부.주문번호
group by 고객.고객번호, 담당자명, 고객회사명
-- order by sum(truncate((단가 * 주문수량 - (주문수량*단가*할인율)),1)) desc;
order by 4 desc; -- 해당 위치의 내용을 그대로 쓸 필요없이 번호만 써도 적용됨

-- 모든 사원의 사원번호, 이름, 부서명 표시
select 사원번호,
	이름,
	부서.부서명
from 사원
inner join 부서
on 사원.부서번호 = 부서.부서번호 -- 
order by 이름;
 

-- 주문번호 'H0255'의 제품명과 주문수량, 단가 표시
-- 테이블이름이 길거나 많은 곳에 사용될 경우, 별명을 사용하는 것이 좋음
select O.주문번호, 
	P.제품명,
	O.주문수량,
	O.단가
from 주문세부 O
inner join 제품 P
on O.제품번호 = P.제품번호
where 주문번호 = 'H0255';

-- Non Equi Join :  =연산자가 아니라 부등호 비교 연산자를 이용한 조인을 말함
-- 즉, on 쓰고나서 무조건 =만 사용하는 것이 아니라는것
-- =의 조건에(둘중 하나는 무조건 Primary Key) 해당되지 않는 경우에 사용하는듯?
-- 
-- ↓ 담당자명이 이은광인 고객중에서 등급이 하한마일리지 이상 상한마일리지 이하인 것 표시
select 고객번호,
	고객회사명,
	담당자명,
	마일리지,
	등급명
from 고객
inner join 마일리지등급
on 마일리지 >= 하한마일리지 and 마일리지 <= 상한마일리지
where 담당자명 = '이은광';

-- 외부조인(outer join, 한쪽 전체, 순서가 중요함) 
-- → inner join(교집합 느낌, 순서가 중요하진 않음)만큼 잘 쓰이진 않음
-- left outer join(from 옆에 붙은 컬럼 기준), right outer join(join 옆에 붙은 컬럼 기준)으로 나뉘어짐
-- 사원 중에 부서가 없는 사원을 확인가능
-- outer 키위드는 생략가능
select 사원번호, 이름, 부서명
from 사원
left join 부서 -- 기존 inner join에서 제외되었던 부서명 없는 사원이 생김
on 사원.부서번호 = 부서.부서번호;
-- 부서중에 사원이 소속되어있지 않은 부서를 확인가능
select 사원번호, 이름, 부서명
from 사원
right outer join 부서 -- 아무도 소속되지 않은 홍보부가 추가됨
on 사원.부서번호 = 부서.부서번호;

-- 셀프조인(self join) : 동일한 테이블 안에서 한 컬럼이 다른 컬럼을 참조하는 경우에 사용
-- → 본인테이블을 한번더 join 하는것(join입력시 self join입력하는것이 아님! inner join임)
-- 마치 동일한 테이블을 다른 테이블인것처럼 조인시키는 방법
select 사원.사원번호,
	사원.이름,
	상사.사원번호 as '상사의 사원번호',
	상사.이름 as '상사의 이름'
from 사원
inner join 사원 as 상사
on 사원.상사번호 = 상사.사원번호;
-- 상사입장에서의 부하 조인
select 사원.사원번호,
	사원.이름,
	상사.사원번호 as '상사의 사원번호',
	상사.이름 as '상사의 이름'
from 사원
right join 사원 as 상사
on 사원.상사번호 = 상사.사원번호;
-- 부하입장에서의 상사 조인(원래의 취지에 맞음 → 상사가 없는 직원까지 포함된 데이터를 요구할 때)
select 사원.사원번호,
	사원.이름,
	상사.사원번호 as '상사의 사원번호',
	상사.이름 as '상사의 이름'
from 사원
left join 사원 as 상사
on 사원.상사번호 = 상사.사원번호;

-- 
